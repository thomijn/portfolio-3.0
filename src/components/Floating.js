/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useEffect } from "react";
import { useGLTF, useAnimations } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import * as THREE from "three";
import useWindowSize from "../hooks/useWindowSize";

export function Floating(props) {
  const group = useRef();
  const { nodes, materials, animations } = useGLTF("/me-floating.glb");
  const { actions } = useAnimations(animations, group);
  const { width } = useWindowSize();

  useEffect(() => {
    actions["Armature|mixamo.com|Layer0"].play();
    //change timescale
    actions["Armature|mixamo.com|Layer0"].timeScale = 0.5;
  }, [actions]);

  let previousPosition = new THREE.Vector3();
  useFrame(({ mouse }) => {
    //lerp light position

    if (width > 768) {
      group.current.position.x = THREE.MathUtils.lerp(
        group.current.position.x,
        mouse.x * 5,
        0.05
      );
      group.current.position.z = THREE.MathUtils.lerp(
        group.current.position.z,
        -mouse.y * 20,
        0.05
      );

      // tilt model when it is moving in a direction based on previous position
      //get distance in x axis
      let distanceX = group.current.position.x - previousPosition.x;
      let distanceY = group.current.position.z - previousPosition.z;

      let distance = previousPosition.distanceTo(group.current.position);

      // scale animation timescale based on distance
      actions["Armature|mixamo.com|Layer0"].timeScale = THREE.MathUtils.lerp(
        actions["Armature|mixamo.com|Layer0"].timeScale,
        distance * 10,
        0.1
      );

      if (group.current.position.x > previousPosition.x) {
        group.current.rotation.z = THREE.MathUtils.lerp(
          group.current.rotation.z,
          distanceX * 2,
          0.1
        );
      } else {
        if (group.current.position.x < previousPosition.x) {
          group.current.rotation.z = THREE.MathUtils.lerp(
            group.current.rotation.z,
            distanceX * 2,
            0.1
          );
        }
      }

      if (group.current.position.z > previousPosition.z) {
        group.current.rotation.x = THREE.MathUtils.lerp(
          group.current.rotation.x,
          distanceY * 0.5,
          0.1
        );
      } else {
        if (group.current.position.z < previousPosition.z) {
          group.current.rotation.x = THREE.MathUtils.lerp(
            group.current.rotation.x,
            distanceY * 0.5,
            0.1
          );
        }
      }

      previousPosition = group.current.position.clone();
    } else {
      //float with sin wave

      group.current.position.x = THREE.MathUtils.lerp(
        group.current.position.x,
        Math.sin(Date.now() * 0.0005) * 0.5,
        0.1
      );
      group.current.position.z = THREE.MathUtils.lerp(
        group.current.position.z,
        Math.sin(Date.now() * 0.0005) * 0.5,
        0.1
      );

      // tilt model when it is moving in a direction based on previous position
      //get distance in x axis
      let distanceX = group.current.position.x - previousPosition.x;
      let distanceY = group.current.position.z - previousPosition.z;

      let distance = previousPosition.distanceTo(group.current.position);

      // scale animation timescale based on distance
      actions["Armature|mixamo.com|Layer0"].timeScale = THREE.MathUtils.lerp(
        actions["Armature|mixamo.com|Layer0"].timeScale,
        distance * 1000,
        0.1
      );

      if (group.current.position.x > previousPosition.x) {
        group.current.rotation.z = THREE.MathUtils.lerp(
          group.current.rotation.z,
          distanceX * 2,
          0.1
        );
      } else {
        if (group.current.position.x < previousPosition.x) {
          group.current.rotation.z = THREE.MathUtils.lerp(
            group.current.rotation.z,
            distanceX * 2,
            0.1
          );
        }
      }

      if (group.current.position.z > previousPosition.z) {
        group.current.rotation.x = THREE.MathUtils.lerp(
          group.current.rotation.x,
          distanceY * 0.5,
          0.1
        );
      } else {
        if (group.current.position.z < previousPosition.z) {
          group.current.rotation.x = THREE.MathUtils.lerp(
            group.current.rotation.x,
            distanceY * 0.5,
            0.1
          );
        }
      }

      previousPosition = group.current.position.clone();
    }
  });

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <group name="Armature" rotation={[Math.PI / 2, 0, 0]} scale={0.01}>
          <primitive object={nodes.mixamorigHips} />
          <skinnedMesh
            name="Mesh_0001"
            geometry={nodes.Mesh_0001.geometry}
            material={materials["Material_0.001"]}
            skeleton={nodes.Mesh_0001.skeleton}
          >
            <meshStandardMaterial smoothShading={true} color={"#fff"} />
          </skinnedMesh>
        </group>
      </group>
    </group>
  );
}

useGLTF.preload("/me-floating.glb");
